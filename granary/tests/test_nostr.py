"""Unit tests for nostr.py."""
from contextlib import contextmanager
import copy
from datetime import timedelta
import logging
import secrets
from threading import Semaphore
from unittest.mock import patch
from urllib.parse import urlparse

from oauth_dropins.webutil import testutil
from oauth_dropins.webutil.testutil import requests_response
from oauth_dropins.webutil import util
from oauth_dropins.webutil.util import HTTP_TIMEOUT, json_dumps, json_loads
import requests
from secp256k1 import PrivateKey, PublicKey
from websockets.exceptions import ConnectionClosedOK, ConnectionClosedError

from .. import nostr
from ..nostr import (
  BECH32_RE,
  bech32_decode,
  bech32_encode,
  from_as1,
  id_for,
  id_to_uri,
  is_bech32,
  KIND_ARTICLE,
  KIND_AUTH,
  KIND_CONTACTS,
  KIND_DELETE,
  KIND_NOTE,
  KIND_PROFILE,
  KIND_REACTION,
  KIND_RELAYS,
  KIND_REPOST,
  to_as1,
  uri_for,
  URI_RE,
  uri_to_id,
)

NOW_TS = int(testutil.NOW.timestamp())
NOW_ISO = testutil.NOW.isoformat()
THEN_TS = NOW_TS - 1
THEN_ISO = (testutil.NOW - timedelta(seconds=1)).isoformat()

ID = '3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d'
URI = 'nostr:note180cvv07tjdrrgpa0j7j7tmnyl2yr6yr7l8j4s3evf6u64th6gkws4c58hj'
NEVENT = 'nevent1qqsrhuxx8l9ex335q7he0f09aej04zpazpl0ne2cgukyawd24mayt8gf9fkma'
URI_NEVENT = 'nostr:' + NEVENT
URI_NPROFILE = 'nostr:nprofile1qqsrhuxx8l9ex335q7he0f09aej04zpazpl0ne2cgukyawd24mayt8g2lcy6q'


PRIVKEY = '1fb759a121ece5e22da48cb20989813fddfc9b2896a4e0207b4ffdd9a0bd189b'
PRIVKEY_2 = 'dadb5ed90eb04a122c5117d2f108778e21b2398952b3d1e4a0d1d8082ddc9efa'
# note that these don't have the original 0x03 prefix generated by the
# secp256k1 library! we add it back (as 0x02) in sign() and verify()
# https://github.com/snarfed/bridgy-fed/issues/446#issuecomment-2927452801
PUBKEY = '32c0619b9f66600bc928eb0680aa578a41fc16bf3bfb600d41c6ce6733cd530c'
PUBKEY_2 = '7d3fd9eea8a6b5521cb8f8bb1b79a00c3d6c92c2f11cd614017843ddd492194c'
PUBKEY_URI = f'nostr:{PUBKEY}'
PUBKEY_URI_2 = f'nostr:{PUBKEY_2}'
# bech32-encoded keys
NPUB = 'npub1xtqxrxulvesqhjfgavrgp2jh3fqlc94l80akqr2pcm8xwv7d2vxqdvp2h2'
NPUB_2 = 'npub105lanm4g5664y89clza3k7dqps7keykz7ywdv9qp0ppam4yjr9xq49gjap'
NPUB_URI = f'nostr:{NPUB}'
NPUB_URI_2 = f'nostr:{NPUB_2}'
NSEC_URI = 'nostr:nsec1r7m4ngfpanj7ytdy3jeqnzvp8lwlexegj6jwqgrmfl7ang9arzdsv9gn7f'
NSEC_URI_2 = 'nostr:nsec1mtd4akgwkp9pytz3zlf0zzrh3csmywvf22eare9q68vqstwunmaquc9uu0'
# signature of NOTE_NOSTR with PRIVKEY
SIG = '65b42db33486f669fa4dff3dba2ed914dcda886d47177a747e5e574e1a87cd4da23b54350dba758ecd91d48625f5345c8516458c76bebf60b0de89d12fa76a11'

NOTE_NOSTR = {
  'kind': KIND_NOTE,
  'id': '4a57c7a1dde3bfe13076db485c4f09756e54447f6389dbf6864d4139bc40a214',
  'pubkey': PUBKEY,
  'content': 'Something to say',
  'tags': [],
  'created_at': NOW_TS,
  'sig': SIG,
}
NOTE_AS1 = {
  'objectType': 'note',
  'id': f'nostr:{NOTE_NOSTR["id"]}',
  'author': PUBKEY_URI,
  'content': 'Something to say',
  'content_is_html': False,
  'published': '2022-01-02T03:04:05+00:00',
  'url': 'https://njump.me/note1fftu0gwauwl7zvrkmdy9cncfw4h9g3rlvwyaha5xf4qnn0zq5g2qrlw3zf',
}

logger = logging.getLogger(__name__)


class FakeConnection:
  """Fake of :class:`websockets.sync.client.ClientConnection`."""
  connected = Semaphore(0)

  @classmethod
  def reset(cls):
    cls.relays = []
    cls.sent = []
    cls.to_receive = []
    cls.closed = False
    cls.recv_err = cls.send_err = None
    cls.connected = Semaphore(0)

  @classmethod
  def send(cls, msg):
    if cls.send_err:
      raise cls.send_err

    assert not cls.closed
    cls.sent.append(json_loads(msg))
    logger.info(msg)

  @classmethod
  def recv(cls, timeout=None):
    assert timeout == HTTP_TIMEOUT

    if not cls.to_receive:
      closed = True
      raise cls.recv_err or ConnectionClosedOK(None, None)

    msg = cls.to_receive.pop(0)
    logger.info(msg)
    return json_dumps(msg)


@contextmanager
def fake_connect(uri, open_timeout=None, close_timeout=None, **kwargs):
  """Fake of :func:`websockets.sync.client.connect`."""
  assert open_timeout == HTTP_TIMEOUT
  assert close_timeout == HTTP_TIMEOUT
  assert uri
  FakeConnection.relays.append(uri)
  FakeConnection.remote_address = (urlparse(uri).netloc, 'port')
  FakeConnection.connected.release()
  yield FakeConnection


class NostrTest(testutil.TestCase):

  def setUp(self):
    super().setUp()
    FakeConnection.reset()

  def test_id_for(self):
    event = {
        'pubkey': 'fed987',
        'created_at': NOW_TS,
        'kind': KIND_NOTE,
        'content': 'My plain text',
    }
    id = '9adfa2330b391539f46548ff2e088ea964a2f7374898c7335a86e914cbf2e769'

    self.assertEqual(id, id_for(event))

    event['sig'] = 'foo'
    self.assertEqual(id, id_for(event))

  def test_uri_for(self):
    self.assertEqual(URI, uri_for({'kind': KIND_NOTE, 'id': ID}))
    self.assertEqual(URI_NPROFILE, uri_for({'kind': KIND_PROFILE, 'id': ID}))
    self.assertEqual(URI_NEVENT, uri_for({'kind': KIND_DELETE, 'id': ID}))

  def test_id_to_uri(self):
    self.assertEqual(URI, id_to_uri('note', ID))
    self.assertEqual(URI_NEVENT, id_to_uri('nevent', ID))
    self.assertEqual(URI_NPROFILE, id_to_uri('nprofile', ID))

  def test_uri_to_id(self):
    self.assertEqual(ID, uri_to_id(URI))
    self.assertEqual('http://not/nostr', uri_to_id('http://not/nostr'))

    # bech-32 with TLV, should ignore the TLVs other than hex id
    id = '0a9b254077729866b0ae7ab70c353807c4f802e9f0db8df7d5f27ed7cc7055bd'
    assert BECH32_RE.match('nevent1qqsq4xe9gpmh9xrxkzh84dcvx5uq038cqt5lpkud7l2lylkhe3c9t0gzyzjzxljzpndskv3369clapumet3h5tdh40e0z23n0wt4xdmp3savyqcyqqqqqqgzg95fu')
    self.assertEqual(id, uri_to_id('nevent1qqsq4xe9gpmh9xrxkzh84dcvx5uq038cqt5lpkud7l2lylkhe3c9t0gzyzjzxljzpndskv3369clapumet3h5tdh40e0z23n0wt4xdmp3savyqcyqqqqqqgzg95fu'))
    # same contents, TLVs are just in a different order
    self.assertEqual(id, uri_to_id('nevent1qgs2ggm7ggxdkzejx8ghrl58n09wx73dk74l9uf2xdaew5ehvxxr4ssrqsqqqqqpqqsq4xe9gpmh9xrxkzh84dcvx5uq038cqt5lpkud7l2lylkhe3c9t0g06gpj8'))

  def test_is_bech32(self):
    self.assertTrue(is_bech32('nostr:npubabc'))
    self.assertTrue(is_bech32('neventabc'))
    self.assertFalse(is_bech32('abc'))
    self.assertFalse(is_bech32(None))

  def test_id_and_asign(self):
    event = copy.deepcopy(NOTE_NOSTR)
    del event['id']
    del event['sig']
    nostr.id_and_sign(event, NSEC_URI)
    self.assertEqual(SIG, event['sig'])

  def test_verify(self):
    missing_sig = copy.copy(NOTE_NOSTR)
    del missing_sig['sig']

    for bad in (
        {},
        missing_sig,
        {**NOTE_NOSTR, 'sig': None},
        {**NOTE_NOSTR, 'id': 'bad', 'sig': SIG},
        {**NOTE_NOSTR, 'pubkey': 'bad', 'sig': SIG},
    ):
      with self.subTest(event=bad):
        self.assertFalse(nostr.verify(bad))

    self.assertTrue(nostr.verify(NOTE_NOSTR))

  def test_pubkey_from_privkey(self):
    self.assertEqual(PUBKEY, nostr.pubkey_from_privkey(PRIVKEY))

  def test_to_from_as1_actor_profile(self):
    person = {
      'objectType': 'person',
      'id': PUBKEY_URI,
      'displayName': 'Alice',
      'summary': 'It me',
      'image': [
        'http://alice/pic',
        {
          'url': 'http://ban/ner',
          'objectType': 'featured',
        },
      ],
      'username': 'alice.com',
      'url': 'http://ali/ce',
      'urls': [
        'http://ali/ce',
        'https://github.com/semisol',
        'https://twitter.com/semisol_public',
        'https://bitcoinhackers.org/@semisol',
        'https://t.me/1087295469',
        'https://njump.me/alice.com',
      ],
      'published': NOW_ISO,
    }
    event = {
      'kind': KIND_PROFILE,
      'pubkey': PUBKEY,
      'id': '5c3dbf8540d62ceee2b8c6f4dde6c732ec13f795f4ad8b46aff5b653a6265a51',
      'content': json_dumps({
        'name': 'Alice',
        'about': 'It me',
        'picture': 'http://alice/pic',
        'nip05': '_@alice.com',
        # https://nips.nostr.com/24
        'banner': 'http://ban/ner',
        'website': 'http://ali/ce',
      }, sort_keys=True),
      'tags': [
        ['i', 'github:semisol', '-'],
        ['i', 'twitter:semisol_public', '-'],
        ['i', 'mastodon:bitcoinhackers.org/@semisol', '-'],
        ['i', 'telegram:1087295469', '-'],
      ],
      'created_at': NOW_TS,
    }
    self.assert_equals(person, to_as1(event))
    self.assert_equals({**person, 'id': PUBKEY}, to_as1(event, nostr_uri_ids=False))
    self.assert_equals({**person, 'id': NPUB_URI}, to_as1(event, id_format='bech32'))
    self.assert_equals({**person, 'id': NPUB},
                        to_as1(event, id_format='bech32', nostr_uri_ids=False))

    # we don't try to detect which URLs might be Mastodon
    del event['tags'][2]
    self.assert_equals(event, from_as1(person))

  def test_from_as1_minimal(self):
    self.assert_equals({
      'kind': KIND_PROFILE,
      'content': json_dumps({'name': 'Alice'}),
      'tags': [],
    }, from_as1({
      'objectType': 'person',
      'displayName': 'Alice',
    }), ignore=['created_at'])

  def test_from_as1_username_not_user_at_domain_no_nip05(self):
    self.assert_equals({
      'kind': KIND_PROFILE,
      'content': json_dumps({'name': 'Alice'}),
      'tags': [],
    }, from_as1({
      'objectType': 'person',
      'displayName': 'Alice',
      'username': 'foo',
    }), ignore=['created_at'])

  def test_from_as1_actor_privkey_sets_pubkey(self):
    self.assert_equals({
      'kind': KIND_PROFILE,
      'id': '8be34ca85471dcb2306ca005182d4468eede8e3a979f84b80f1a9616e84f4c74',
      'pubkey': PUBKEY,
      'content': json_dumps({'name': 'Alice'}),
      'tags': [],
      'sig': '54173e03ea1608c1c99b40532a68c824c3e2558628286d13271277f8811d08823484d4708a299182310c2a5480aa3966772c99214531937437fc900a361288f0',
      'created_at': NOW_TS,
    }, from_as1({
      'objectType': 'person',
      'displayName': 'Alice',
    }, privkey=NSEC_URI))

  def test_to_as1_profile_bad_nip05(self):
    event = {
      'kind': KIND_PROFILE,
      'pubkey': PUBKEY,
      'content': '{"nip05": {}}',
    }
    self.assert_equals({
      'objectType': 'person',
      'id': PUBKEY_URI,
    }, to_as1(event))
    self.assert_equals({
      'objectType': 'person',
      'id': NPUB_URI,
    }, to_as1(event, id_format='bech32'))

  def test_to_as1_profile_no_content(self):
    self.assert_equals({
      'objectType': 'person',
      'id': PUBKEY_URI,
    }, to_as1({
      'kind': KIND_PROFILE,
      'pubkey': PUBKEY,
    }))

  def test_to_from_as1_note(self):
    id = '4a57c7a1dde3bfe13076db485c4f09756e54447f6389dbf6864d4139bc40a214'
    note = {
      'objectType': 'note',
      'id': f'nostr:{id}',
      'author': PUBKEY_URI,
      'content': 'Something to say',
      'content_is_html': False,
      'published': NOW_ISO,
      'url': f'https://njump.me/{bech32_encode("note", id)}',
    }
    event = {
      'kind': KIND_NOTE,
      'id': id,
      'pubkey': PUBKEY,
      'content': 'Something to say',
      'created_at': NOW_TS,
      'tags': [],
    }
    self.assert_equals(note, to_as1(event))
    self.assert_equals({
      **note,
      'id': 'note1fftu0gwauwl7zvrkmdy9cncfw4h9g3rlvwyaha5xf4qnn0zq5g2qrlw3zf',
      'author': NPUB,
    }, to_as1(event, id_format='bech32', nostr_uri_ids=False))
    self.assert_equals(event, from_as1(note))

  def test_to_from_as1_note_html_content(self):
    self.assert_equals({
      **NOTE_NOSTR,
      'content': 'hi _there_\n\n  * 1\n  * 2\n',
    }, from_as1({
      **NOTE_AS1,
      'content': '<p>hi <em>there</em></p><ul><li>1<li>2</ul>',
    }), ignore=['id', 'sig'])

  def test_from_as1_post_activity(self):
    self.assert_equals(NOTE_NOSTR, from_as1({
      'objectType': 'activity',
      'verb': 'post',
      'object': NOTE_AS1,
    }), ignore=['sig'])

  def test_from_as1_update_activity(self):
    self.assert_equals(NOTE_NOSTR, from_as1({
      'objectType': 'activity',
      'verb': 'update',
      'object': NOTE_AS1,
    }), ignore=['sig'])

  def test_from_as1_post_activity_with_proxy_tag(self):
    self.assert_equals({
      **NOTE_NOSTR,
      'tags': [['proxy', 'proxy-id', 'proxy-proto']],
    }, from_as1({
      'objectType': 'activity',
      'verb': 'post',
      'object': {
        **NOTE_AS1,
        'id': 'https://example.com/note/123',
      },
    }, proxy_tag=('proxy-id', 'proxy-proto')), ignore=['id', 'sig'])

  def test_from_as1_reject_activity_not_implemented(self):
    with self.assertRaises(NotImplementedError):
      from_as1({
        'objectType': 'activity',
        'verb': 'reject',
        'object': NOTE_AS1,
      })

  def test_from_as1_with_privkey(self):
    self.assert_equals(NOTE_NOSTR, from_as1(NOTE_AS1, NSEC_URI))

  def test_from_as1_privkey_sets_pubkey(self):
    self.assert_equals(NOTE_NOSTR, from_as1({
      **NOTE_AS1,
      'author': None,
    }, NSEC_URI))

  def test_to_from_as1_note_subject_tag(self):
    note = {
      'objectType': 'note',
      'author': PUBKEY_URI,
      'content': 'Something to say',
      'content_is_html': False,
      'title': 'my thing',
    }
    event = {
      'kind': KIND_NOTE,
      'pubkey': PUBKEY,
      'content': 'Something to say',
      'tags': [
        ['title', 'my thing'],
        ['subject', 'my thing'],
      ],
    }
    self.assert_equals(note, to_as1(event))
    self.assert_equals(event, from_as1(note), ignore=['id', 'created_at'])

  def test_to_from_as1_note_with_hashtag(self):
    id = 'aff5813b667be4a7e4a4d5d3196b8987150f67331bcb9822549b5ebbe6a843ef'
    note = {
      'objectType': 'note',
      'id': f'nostr:{id}',
      'author': PUBKEY_URI,
      'content': 'Something to say',
      'content_is_html': False,
      'published': NOW_ISO,
      'tags': [{
        'objectType': 'hashtag',
        'displayName': 'foo',
      }, {
        'objectType': 'hashtag',
        'displayName': 'bar',
      }],
      'url': f'https://njump.me/{bech32_encode("note", id)}',
    }
    event = {
      'kind': KIND_NOTE,
      'id': id,
      'pubkey': PUBKEY,
      'content': 'Something to say',
      'created_at': NOW_TS,
      'tags': [
        ['t', 'foo'],
        ['t', 'bar'],
      ],
    }
    self.assert_equals(note, to_as1(event))
    self.assert_equals(event, from_as1(note))

  def test_from_as1_note_with_mention_tags(self):
    note = {
      'objectType': 'note',
      'author': PUBKEY_URI,
      'content': 'Hey @alice and @bob and @eve ok',
      'content_is_html': False,
      'tags': [{
        'objectType': 'mention',
        'url': PUBKEY_URI_2,
        'displayName': '@alice',
        'startIndex': 4,
        'length': 6,
      }, {
        'objectType': 'mention',
        'url': PUBKEY_URI,
        'displayName': '@bob',
        'startIndex': 15,
        'length': 4,
      }, {
        'objectType': 'mention',
        'url': 'https://example.com/@eve',
        'displayName': '@eve',
        'startIndex': 24,
        'length': 4,
      }],
    }
    expected = {
      'kind': KIND_NOTE,
      'pubkey': PUBKEY,
      'content': f'Hey {NPUB_URI_2} and {NPUB_URI} and @eve ok',
      'created_at': NOW_TS,
      'tags': [
        ['p', PUBKEY_2],
        ['p', PUBKEY],
      ],
    }
    self.assert_equals(expected, from_as1(note), ignore=['id', 'sig'])

  def test_from_as1_note_with_mention_tag_html_content(self):
    note = {
      'objectType': 'note',
      'author': PUBKEY_URI,
      'content': '<p>Hello <a href="https://example.com">@alice</a>!</p>',
      'content_is_html': True,
      'tags': [{
        'objectType': 'mention',
        'url': PUBKEY_URI_2,
        'displayName': '@alice',
        'startIndex': 20,
        'length': 6,
      }],
    }
    expected = {
      'kind': KIND_NOTE,
      'pubkey': PUBKEY,
      'content': 'Hello @alice!',
      'created_at': NOW_TS,
      'tags': [['p', PUBKEY_2]],
    }
    self.assert_equals(expected, from_as1(note), ignore=['id', 'sig'])

  def test_from_as1_note_with_mention_tag_without_indices(self):
    note = {
      'objectType': 'note',
      'author': PUBKEY_URI,
      'content': 'Hello @alice!',
      'content_is_html': False,
      'tags': [{
        'objectType': 'mention',
        'url': PUBKEY_URI_2,
        'displayName': '@alice',
      }],
    }
    expected = {
      'kind': KIND_NOTE,
      'pubkey': PUBKEY,
      'content': 'Hello @alice!',
      'created_at': NOW_TS,
      'tags': [['p', PUBKEY_2]],
    }
    self.assert_equals(expected, from_as1(note), ignore=['id', 'sig'])

  def test_to_from_as1_note_with_image(self):
    id = '51c9a64dc4f00590d76fdf01af9c7e75ddb15810e8da2b0783227500447f2c37'
    note = {
      'objectType': 'note',
      'id': f'nostr:{id}',
      'author': PUBKEY_URI,
      'content': 'Something to say',
      'content_is_html': False,
      'published': NOW_ISO,
      'image': [
        'http://pic/1.png',
        {
          'objectType': 'image',
          'url': 'http://pic/2',
          'mimeType': 'image/jpeg',
          'displayName': 'my alt text',
        },
      ],
      'url': f'https://njump.me/{bech32_encode("note", id)}',
    }
    event = {
      'kind': KIND_NOTE,
      'id': id,
      'pubkey': PUBKEY,
      'content': 'Something to say http://pic/1.png http://pic/2',
      'created_at': NOW_TS,
      'tags': [[
        'imeta',
        'url http://pic/1.png',
        'alt ',
        'm image/png',
      ], [
        'imeta',
        'url http://pic/2',
        'm image/jpeg',
        'alt my alt text',
      ]],
    }

    self.assert_equals(event, from_as1(note))

    note['image'][0] = {
      'objectType': 'image',
      'url': 'http://pic/1.png',
      'mimeType': 'image/png',
    }
    self.assert_equals(note, to_as1(event))

  def test_to_from_as1_note_with_video_audio(self):
    id = 'ed8312b06730cf57793b8b354331b9fa0a85c9823ad2352865504613afb2f3af'
    note = {
      'objectType': 'note',
      'id': f'nostr:{id}',
      'author': PUBKEY_URI,
      'content': 'Something to say',
      'content_is_html': False,
      'published': NOW_ISO,
      'attachments': [{
        'objectType': 'audio',
        'stream': {'url': 'http://a/podcast.mp3'},
      }, {
        'objectType': 'video',
        # TODO
        # 'displayName': 'my alt text',
        'stream': {'url': 'http://a/vidjo.mov'},
      }],
      'url': f'https://njump.me/{bech32_encode("note", id)}',
    }
    event = {
      'kind': KIND_NOTE,
      'id': id,
      'pubkey': PUBKEY,
      'content': 'Something to say http://a/podcast.mp3 http://a/vidjo.mov',
      'created_at': NOW_TS,
      'tags': [[
        'imeta',
        'url http://a/podcast.mp3',
        'alt ',
        'm audio/mpeg',
      ], [
        'imeta',
        'url http://a/vidjo.mov',
        'alt ',
        'm video/quicktime',
      ]],
    }

    self.assert_equals(event, from_as1(note))

    note['attachments'][0]['stream']['mimeType'] = 'audio/mpeg'
    note['attachments'][1]['stream']['mimeType'] = 'video/quicktime'
    self.assert_equals(note, to_as1(event))

  def test_to_from_as1_note_with_location(self):
    id = 'b6fef17709ae65ed97fa57a9705fcf0d88948d65935989584516d8e89a5ac0c7'
    note = {
      'objectType': 'note',
      'id': f'nostr:{id}',
      'author': PUBKEY_URI,
      'content': 'Something to say',
      'content_is_html': False,
      'published': NOW_ISO,
      'location': {
        'displayName': 'my house',
      },
      'url': f'https://njump.me/{bech32_encode("note", id)}',
    }
    event = {
      'kind': KIND_NOTE,
      'id': id,
      'pubkey': PUBKEY,
      'content': 'Something to say',
      'created_at': NOW_TS,
      'tags': [
        ['location', 'my house'],
      ],
    }
    self.assert_equals(note, to_as1(event))
    self.assert_equals(event, from_as1(note))

  def test_to_from_as1_article(self):
    id = '2f395bebb3be5f4738a24f70fea33b7067902eea261fc7b24ba4559f32312acd'
    note = {
      'objectType': 'article',
      'id': 'http://art/icle',
      'author': PUBKEY_URI,
      'title': 'a thing',
      'summary': 'about the thing',
      'content': 'Something to say',
      'content_is_html': False,
      'published': NOW_ISO,
      'url': f'https://njump.me/{bech32_encode("nevent", id)}',
    }
    event = {
      'kind': KIND_ARTICLE,
      'id': id,
      'pubkey': PUBKEY,
      'content': 'Something to say',
      'created_at': NOW_TS,
      'tags': [
        # TODO: NIP-33 'd' tag for slug
        ['published_at', str(NOW_TS)],
        ['title', 'a thing'],
        ['subject', 'a thing'],
        ['summary', 'about the thing'],
        ['d', 'http://art/icle']
      ],
    }
    self.assert_equals(note, to_as1(event))
    self.assert_equals(event, from_as1(note))

  def test_to_as1_relays(self):
    self.assert_equals({
      'id': f'nostr:{ID}',
      'author': PUBKEY_URI,
    }, to_as1({
      'id': ID,
      'kind': KIND_RELAYS,
      'pubkey': PUBKEY,
      'tags': [
        ['r', 'wss://nostr.onsats.org/'],
      ],
    }))

  def test_from_as1_with_proxy_tag(self):
    self.assert_equals({
      **NOTE_NOSTR,
      'tags': [['proxy', 'proxy-id', 'proxy-proto']],
    }, from_as1({
      **NOTE_AS1,
      'id': 'at://did:plc:123/app.bsky.feed.post/456',
    }, proxy_tag=('proxy-id', 'proxy-proto')), ignore=['id', 'sig'])

  def test_to_from_as1_reply(self):
    reply = {
      'objectType': 'note',
      'author': PUBKEY_URI,
      'published': NOW_ISO,
      'content': 'I hereby reply',
      'content_is_html': False,
      'inReplyTo': f'nostr:{ID}',
    }
    event = {
      'kind': KIND_NOTE,
      'pubkey': PUBKEY,
      'content': 'I hereby reply',
      'tags': [
        ['e', ID, '', 'reply'],
      ],
      'created_at': NOW_TS,
    }

    self.assert_equals(reply, to_as1(event))
    self.assert_equals({
      **reply,
      'inReplyTo': NEVENT,
      'author': NPUB,
    }, to_as1(event, id_format='bech32', nostr_uri_ids=False))

    event['tags'][0][3] = 'root'
    self.assert_equals(reply, to_as1(event), ignore=['id'])


    event['tags'][0] = ['e', ID, '']
    for type in 'note', 'comment':
      self.assert_equals(event, from_as1({**reply, 'objectType': type}), ignore=['id'])
      self.assert_equals(event, from_as1({**reply, 'objectType': type}), ignore=['id'])

    event['tags'][0][-1] = 'reelaay'
    self.assert_equals(event, from_as1(reply, remote_relay='reelaay'), ignore=['id'])

  def test_to_from_as1_reply_with_author(self):
    id = '51c8b67a90beb1e02f7316f6a18054a5d4655638036913347763aa169ee28bde'
    reply = {
      'objectType': 'note',
      'id': f'nostr:{id}',
      'author': PUBKEY_URI,
      'published': NOW_ISO,
      'content': 'I hereby reply',
      'inReplyTo': {
        'id': f'nostr:{ID}',
        'author': PUBKEY_URI_2,
      },
    }
    event = {
      'kind': KIND_NOTE,
      'id': id,
      'pubkey': PUBKEY,
      'content': 'I hereby reply',
      'tags': [
        ['e', ID, '', '', PUBKEY_2],
        ['p', PUBKEY_2],
      ],
      'created_at': NOW_TS,
    }
    self.assert_equals(event, from_as1(reply))

  def test_to_from_as1_repost(self):
    post_id = 'd00989ef1d71950617fd933d564b091b525f94cff082758e0ebe814559443a62'
    repost = {
      'objectType': 'activity',
      'verb': 'share',
      'published': THEN_ISO,
      'object': {
        'objectType': 'note',
        'id': f'nostr:{post_id}',
        'author': PUBKEY_URI,
        'content': 'The orig post',
        'content_is_html': False,
        'published': NOW_ISO,
        'url': f'https://njump.me/{bech32_encode("note", post_id)}',
      },
    }
    event = {
      'kind': KIND_REPOST,
      'content': json_dumps({
        'kind': KIND_NOTE,
        'id': post_id,
        'pubkey': PUBKEY,
        'content': 'The orig post',
        # TODO: preserve published time from inner object
        'created_at': NOW_TS,
        'tags': [],
      }, sort_keys=True),
      'tags': [
        ['e', post_id, '', '', PUBKEY],
        ['p', PUBKEY],
      ],
      'created_at': THEN_TS,
    }

    self.assert_equals(repost, to_as1(event))

    expected_event = {
      **event,
      'created_at': NOW_TS,
    }
    self.assert_equals(expected_event, from_as1(repost))

    event['tags'][0][3] = ['reelaay']
    self.assert_equals(expected_event, from_as1(repost, remote_relay=['reelaay']))

    del event['content']
    repost['object'] = {
      'id': f'nostr:{post_id}',
      'author': PUBKEY_URI,
    }
    self.assert_equals(repost, to_as1(event))

    del event['tags'][0][4]
    repost['object'] = f'nostr:{post_id}'
    self.assert_equals(repost, to_as1(event))

  def test_from_as1_repost_compacted_object(self):
    self.assert_equals({
      'kind': KIND_REPOST,
      'content': '',
      'tags': [['e', 'abc123', '', '']],
      'created_at': NOW_TS,
    }, from_as1({
      'objectType': 'activity',
      'verb': 'share',
      'object': 'nostr:abc123',
    }))

  def test_to_from_as1_like(self):
    like = {
      'objectType': 'activity',
      'verb': 'like',
      'published': NOW_ISO,
      'object': f'nostr:{ID}',
    }
    event = {
      'kind': KIND_REACTION,
      'content': '+',
      'tags': [['e', ID]],
      'created_at': NOW_TS,
    }

    self.assert_equals(like, to_as1(event))
    self.assert_equals(event, from_as1(like))

  def test_to_from_as1_dislike(self):
    like = {
      'objectType': 'activity',
      'verb': 'dislike',
      'published': NOW_ISO,
      'object': f'nostr:{ID}',
    }
    event = {
      'kind': KIND_REACTION,
      'content': '-',
      'tags': [['e', ID]],
      'created_at': NOW_TS,
    }

    self.assert_equals(like, to_as1(event))
    self.assert_equals(event, from_as1(like))

  def test_to_from_as1_reaction(self):
    react = {
      'objectType': 'activity',
      'verb': 'react',
      'content': 'ðŸ˜€',
      'published': NOW_ISO,
      'object': f'nostr:{ID}',
    }
    event = {
      'kind': KIND_REACTION,
      'content': 'ðŸ˜€',
      'tags': [['e', ID]],
      'created_at': NOW_TS,
    }

    self.assert_equals(react, to_as1(event))
    self.assert_equals(event, from_as1(react))

  def test_to_from_as1_delete(self):
    delete = {
      'objectType': 'activity',
      'verb': 'delete',
      'published': NOW_ISO,
      'object': f'nostr:{ID}',
      'content': 'a note about the delete',
    }
    event = {
      'kind': KIND_DELETE,
      'content': 'a note about the delete',
      'tags': [['e', ID]],
      'created_at': NOW_TS,
    }

    self.assert_equals(delete, to_as1(event))
    self.assert_equals(event, from_as1(delete))

  def test_to_from_as1_followings(self):
    id = 'd5bb6dd9cdc5e782992f1bfda10b817ff0c949419da9b21addf50095b16dab1a'
    follow = {
      'objectType': 'activity',
      'verb': 'follow',
      'id': f'nostr:{id}',
      'actor': PUBKEY_URI,
      'published': NOW_ISO,
      'object': [
        PUBKEY_URI,
        {'id': PUBKEY_URI, 'displayName': 'bob'},
      ],
      'content': 'not important',
    }
    event = {
      'kind': KIND_CONTACTS,
      'id': id,
      'pubkey': PUBKEY,
      'content': 'not important',
      'tags': [
        ['p', PUBKEY, '', ''],
        ['p', PUBKEY, '', 'bob'],
      ],
      'created_at': NOW_TS,
    }

    self.assert_equals(follow, to_as1(event))
    self.assert_equals(event, from_as1(follow))

    event['tags'] = [
        ['p', PUBKEY, 'reelaay', ''],
        ['p', PUBKEY, 'reelaay', 'bob'],
    ]
    self.assert_equals(event, from_as1(follow, remote_relay='reelaay'), ignore=['id'])

  @patch('requests.get', return_value=requests_response({'names': {'alice': PUBKEY}}))
  def test_nip05_to_npub(self, mock_get):
    npub = nostr.nip05_to_npub('alice@example.com')
    self.assertEqual(NPUB, npub)
    mock_get.assert_any_call('https://example.com/.well-known/nostr.json?name=alice',
                             timeout=HTTP_TIMEOUT, stream=True,
                             headers={'User-Agent': util.user_agent})

  @patch('requests.get', return_value=requests_response({'names': {'_': PUBKEY}}))
  def test_nip05_to_npub_underscore_username(self, mock_get):
    npub = nostr.nip05_to_npub('_@example.com')
    self.assertEqual(NPUB, npub)
    mock_get.assert_any_call('https://example.com/.well-known/nostr.json?name=_',
                             timeout=HTTP_TIMEOUT, stream=True,
                             headers={'User-Agent': util.user_agent})

  @patch('requests.get', return_value=requests_response({'names': {'_': PUBKEY}}))
  def test_nip05_to_npub_bare_domain(self, mock_get):
    npub = nostr.nip05_to_npub('example.com')
    self.assertEqual(NPUB, npub)
    mock_get.assert_any_call('https://example.com/.well-known/nostr.json?name=_',
                             timeout=HTTP_TIMEOUT, stream=True,
                             headers={'User-Agent': util.user_agent})

  @patch('requests.get', return_value=requests_response({'names': {'bob': PUBKEY}}))
  def test_nip05_to_npub_user_not_found(self, mock_get):
    with self.assertRaises(ValueError) as cm:
      nostr.nip05_to_npub('alice@example.com')

    self.assertEqual('User alice not found at example.com', str(cm.exception))

  @patch('requests.get', return_value=requests_response('', status=404))
  def test_nip05_to_npub_http_error(self, mock_get):
    with self.assertRaises(requests.HTTPError):
      nostr.nip05_to_npub('alice@example.com')

    mock_get.assert_any_call('https://example.com/.well-known/nostr.json?name=alice',
                             timeout=HTTP_TIMEOUT, stream=True,
                             headers={'User-Agent': util.user_agent})

  @patch('requests.get', return_value=requests_response('not json'))
  def test_nip05_to_npub_invalid_json(self, mock_get):
    with self.assertRaises(ValueError):
      nostr.nip05_to_npub('alice@example.com')

    mock_get.assert_any_call('https://example.com/.well-known/nostr.json?name=alice',
                             timeout=HTTP_TIMEOUT, stream=True,
                             headers={'User-Agent': util.user_agent})

  def test_nip05_to_npub_invalid_input(self):
    for bad in ('', 'too@many@ats', 'alice@', '@example.com'):
      with self.subTest(nip05=bad):
        with self.assertRaises(ValueError):
          nostr.nip05_to_npub(bad)


class ClientTest(testutil.TestCase):
  last_token = None

  def setUp(self):
    super().setUp()

    self.last_token = 0
    self.mox.stubs.Set(secrets, 'token_urlsafe', self.token)

    FakeConnection.reset()

    nostr.connect = fake_connect

    self.nostr = nostr.Nostr(['ws://relay'], privkey=NSEC_URI)

  def token(self, length):
    self.last_token += 1
    return f'towkin {self.last_token}'

  def test_constructor_without_privkey(self):
    nostr.Nostr(['ws://relay'])  # just check that we don't crash

  def test_activity_id(self):
    FakeConnection.to_receive = [
      ['EVENT', 'towkin 1', NOTE_NOSTR],
      ['EOSE', 'towkin 1'],
      ['not', 'reached']
    ]

    self.assert_equals([NOTE_AS1], self.nostr.get_activities(activity_id='ab12'))

    self.assertEqual(['ws://relay'], FakeConnection.relays)
    self.assert_equals([
      ['REQ', 'towkin 1', {'ids': ['ab12'], 'limit': 20}],
      ['CLOSE', 'towkin 1'],
    ], FakeConnection.sent)
    self.assertEqual([['not', 'reached']], FakeConnection.to_receive)

  def test_user_id(self):
    events = [nostr.id_and_sign({
        **NOTE_NOSTR,
        'content': f"It's {i}",
        'id': None,
        'sig': None,
      } , NSEC_URI) for i in range(3)]

    notes = [{
      **NOTE_AS1,
      'id': f'nostr:{event["id"]}',
      'content': f"It's {i}",
      'url': f'https://njump.me/{bech32_encode("note", event["id"])}',
    } for i, event in enumerate(events)]

    FakeConnection.to_receive = \
      [['EVENT', 'towkin 1', e] for e in events] + [['EOSE', 'towkin 1']]

    self.assert_equals(notes, self.nostr.get_activities(user_id='ab12', count=3))
    self.assert_equals([
      ['REQ', 'towkin 1', {'authors': ['ab12'], 'limit': 3}],
      ['CLOSE', 'towkin 1'],
    ], FakeConnection.sent)
    self.assertEqual([], FakeConnection.to_receive)

  def test_search(self):
    FakeConnection.to_receive = \
      [['EVENT', 'towkin 1', NOTE_NOSTR]] + [['EOSE', 'towkin 1']]

    self.assert_equals([NOTE_AS1],
                       self.nostr.get_activities(search_query='surch'))
    self.assert_equals([
      ['REQ', 'towkin 1', {'search': 'surch', 'limit': 20}],
      ['CLOSE', 'towkin 1'],
    ], FakeConnection.sent)

  def test_fetch_replies(self):
    reply_nostr = nostr.id_and_sign({
      'kind': KIND_NOTE,
      'pubkey': PUBKEY,
      'content': 'I hereby reply',
      'tags': [['e', NOTE_NOSTR['id'], 'TODO relay', 'reply']],
    }, NSEC_URI)

    reply_as1 = {
      'objectType': 'note',
      'id': f'nostr:{reply_nostr["id"]}',
      'author': PUBKEY_URI,
      'content': 'I hereby reply',
      'content_is_html': False,
      'inReplyTo': f'nostr:{NOTE_NOSTR["id"]}',
      'published': NOW_ISO,
      'url': f'https://njump.me/{bech32_encode("note", reply_nostr["id"])}',
    }

    FakeConnection.to_receive = [
      ['EVENT', 'towkin 1', NOTE_NOSTR],
      ['EOSE', 'towkin 1'],
      ['EVENT', 'towkin 2', reply_nostr],
      ['EVENT', 'towkin 2', reply_nostr],
      ['EOSE', 'towkin 2'],
    ]

    self.assert_equals([
      {**NOTE_AS1, 'replies': {'totalItems': 2, 'items': [reply_as1] * 2}},
    ], self.nostr.get_activities(user_id=PUBKEY, fetch_replies=True))

    self.assertEqual(['ws://relay'], FakeConnection.relays)
    self.assert_equals([
      ['REQ', 'towkin 1', {'authors': [PUBKEY], 'limit': 20}],
      ['CLOSE', 'towkin 1'],
      ['REQ', 'towkin 2', {'#e': [NOTE_NOSTR['id']], 'limit': 20}],
      ['CLOSE', 'towkin 2'],
    ], FakeConnection.sent)

  def test_fetch_shares(self):
    repost_nostr = nostr.id_and_sign({
      'kind': KIND_REPOST,
      'pubkey': PUBKEY,
      'content': None,
      'tags': [['e', NOTE_NOSTR['id'], 'TODO relay', '']],
    } , NSEC_URI)

    repost_as1 = {
      'objectType': 'activity',
      'actor': PUBKEY_URI,
      'verb': 'share',
      'id': f'nostr:{repost_nostr["id"]}',
      'object': f'nostr:{NOTE_NOSTR["id"]}',
      'published': NOW_ISO,
      'url': f'https://njump.me/{bech32_encode("nevent", repost_nostr["id"])}',
    }

    FakeConnection.to_receive = [
      ['EVENT', 'towkin 1', NOTE_NOSTR],
      ['EOSE', 'towkin 1'],
      ['EVENT', 'towkin 2', repost_nostr],
      ['EVENT', 'towkin 2', repost_nostr],
      ['EOSE', 'towkin 2'],
    ]

    self.assert_equals([
      {**NOTE_AS1, 'tags': [repost_as1, repost_as1]},
    ], self.nostr.get_activities(user_id=PUBKEY, fetch_shares=True))

    self.assertEqual(['ws://relay'], FakeConnection.relays)
    self.assert_equals([
      ['REQ', 'towkin 1', {'authors': [PUBKEY], 'limit': 20}],
      ['CLOSE', 'towkin 1'],
      ['REQ', 'towkin 2', {'#e': [NOTE_NOSTR['id']], 'limit': 20}],
      ['CLOSE', 'towkin 2'],
    ], FakeConnection.sent)

  def test_ok_false_closes_query(self):
    FakeConnection.to_receive = [
      ['OK', 'towkin 1', False],
      ['EVENT', 'towkin 1', NOTE_NOSTR],
    ]

    self.assert_equals([], self.nostr.get_activities())
    self.assert_equals([['EVENT', 'towkin 1', NOTE_NOSTR]], FakeConnection.to_receive)

  def test_create_note(self):
    FakeConnection.to_receive = [
      ['OK', NOTE_NOSTR['id'], True],
    ]

    expected = {
      **NOTE_NOSTR,
      'created_at': NOW_TS,
    }
    result = self.nostr.create(NOTE_AS1)
    self.assert_equals(expected, result.content)
    self.assert_equals([['EVENT', expected]], FakeConnection.sent)

  def test_create_note_default_pubkey(self):
    FakeConnection.to_receive = [
      ['OK', NOTE_NOSTR['id'], True],
    ]

    expected = {
      **NOTE_NOSTR,
      'created_at': NOW_TS,
    }
    result = self.nostr.create(NOTE_AS1)
    self.assert_equals(expected, result.content)
    self.assert_equals([['EVENT', expected]], FakeConnection.sent)

  def test_create_note_ok_false(self):
    FakeConnection.to_receive = [
      ['OK', NOTE_NOSTR['id'], False, 'foo bar'],
    ]

    result = self.nostr.create(NOTE_AS1)
    self.assertEqual('foo bar', result.error_plain)
    self.assertTrue(result.abort)

  def test_delete_note(self):
    id = 'nostr:npub1z24szqzphd'
    expected = nostr.id_and_sign({
      'pubkey': PUBKEY,
      'kind': KIND_DELETE,
      'tags': [['e', uri_to_id(id)]],
      'content': '',
      'created_at': NOW_TS,
    }, NSEC_URI)

    FakeConnection.to_receive = [
      ['OK', expected['id'], True],
    ]

    result = self.nostr.delete(id)
    self.assert_equals(expected, result.content, result)
    self.assert_equals([['EVENT', expected]], FakeConnection.sent)

  def test_get_actor_npub(self):
    profile = nostr.id_and_sign({
      'kind': KIND_PROFILE,
      'pubkey': PUBKEY,
      'content': json_dumps({
        'name': 'Alice',
        'nip05': '_@alice.com',
      }, sort_keys=True),
    } , NSEC_URI)

    FakeConnection.to_receive = [
      ['EVENT', 'towkin 1', profile],
      ['EOSE', 'towkin 1'],
    ]

    person = {
      'objectType': 'person',
      'id': PUBKEY_URI,
      'displayName': 'Alice',
      'username': 'alice.com',
      'published': NOW_ISO,
      'urls': [f'https://njump.me/alice.com'],
    }

    self.assert_equals(person, self.nostr.get_actor(user_id='nostr:npub1z24szqzphd'))
    self.assert_equals([
      ['REQ', 'towkin 1', {'authors': ['12ab'], 'kinds': [KIND_PROFILE], 'limit': 20}],
      ['CLOSE', 'towkin 1'],
    ], FakeConnection.sent)

  def test_query_connection_closed_ok_send_immediate(self):
    FakeConnection.send_err = ConnectionClosedOK(None, None)

    with fake_connect('wss://my-relay',
                      open_timeout=HTTP_TIMEOUT,
                      close_timeout=HTTP_TIMEOUT,
                      ) as ws:
      self.assertEqual([], self.nostr.query(ws, {}))

  def test_query_connection_closed_ok_recv_immediate(self):
    FakeConnection.recv_err = ConnectionClosedOK(None, None)

    with fake_connect('wss://my-relay',
                      open_timeout=HTTP_TIMEOUT,
                      close_timeout=HTTP_TIMEOUT,
                      ) as ws:
      self.assertEqual([], self.nostr.query(ws, {}))

  def test_query_connection_closed_ok_recv_partial_results(self):
    FakeConnection.to_receive = [
      ['EVENT', 'towkin 1', NOTE_NOSTR],
      ['EVENT', 'towkin 1', NOTE_NOSTR],
    ]
    FakeConnection.recv_err = ConnectionClosedOK(None, None)

    with fake_connect('wss://my-relay',
                      open_timeout=HTTP_TIMEOUT,
                      close_timeout=HTTP_TIMEOUT,
                      ) as ws:
      self.assert_equals([NOTE_NOSTR, NOTE_NOSTR], self.nostr.query(ws, {}))

  def test_query_connection_closed_error_recv_raises(self):
    FakeConnection.to_receive = [
      ['EVENT', 'towkin 1', NOTE_NOSTR],
    ]
    FakeConnection.recv_err = ConnectionClosedError(None, None)

    with fake_connect('wss://my-relay',
                      open_timeout=HTTP_TIMEOUT,
                      close_timeout=HTTP_TIMEOUT,
                      ) as ws:
      with self.assertRaises(ConnectionClosedError):
        self.nostr.query(ws, {})

  def test_query_signature_verification(self):
    no_sig = copy.deepcopy(NOTE_NOSTR)
    del no_sig['sig']

    no_pubkey = copy.deepcopy(NOTE_NOSTR)
    del no_pubkey['pubkey']

    FakeConnection.to_receive = [
      ['EVENT', 'towkin 1', NOTE_NOSTR],
      ['EVENT', 'towkin 1', {**NOTE_NOSTR, 'sig': 'badd'}],
      ['EVENT', 'towkin 1', no_sig],
      ['EVENT', 'towkin 1', no_pubkey],
      ['EOSE', 'towkin 1'],
    ]

    with fake_connect('wss://my-relay',
                      open_timeout=HTTP_TIMEOUT,
                      close_timeout=HTTP_TIMEOUT,
                      ) as ws:
      events = self.nostr.query(ws, {})

    # Only the valid event should be returned
    self.assert_equals([NOTE_NOSTR], events)

  def test_query_nip_42_auth(self):
    challenge = nostr.id_and_sign({
      'kind': KIND_AUTH,
      'pubkey': PUBKEY,
      'content': '',
      'tags': [
        ['relay', 'wss://my-relay/'],
        ['challenge', 'chall-lunge'],
      ],
    }, NSEC_URI)

    FakeConnection.to_receive = [
      ['AUTH', 'chall-lunge'],
      ['OK', challenge['id'], True, ''],
      ['EVENT', 'towkin 1', NOTE_NOSTR],
      ['EOSE', 'towkin 1'],
    ]

    with fake_connect('wss://my-relay',
                      open_timeout=HTTP_TIMEOUT,
                      close_timeout=HTTP_TIMEOUT,
                      ) as ws:
      events = self.nostr.query(ws, {})

    self.assert_equals([NOTE_NOSTR], events)
    self.assert_equals([
      ['AUTH', challenge],
      ['REQ', 'towkin 1', {'limit': 20}],
      ['CLOSE', 'towkin 1'],
    ], FakeConnection.sent)

  def test_object_url(self):
    for input, expected in (
        (None, None),
        ('npub123', 'https://njump.me/npub123'),
        ('nostr:npub123', 'https://njump.me/nostr:npub123'),
        ('foo.com', 'https://njump.me/foo.com'),
        ('foo@bar.com', 'https://njump.me/foo@bar.com'),
    ):
      with self.subTest(input=input):
        self.assertEqual(expected, self.nostr.object_url(input))

  def test_bech32_re(self):
    self.assertIsNone(BECH32_RE.match(ID))
    self.assertIsNone(BECH32_RE.match(URI))
    self.assertIsNotNone(BECH32_RE.match(URI.removeprefix('nostr:')))
    self.assertIsNotNone(BECH32_RE.match(NEVENT))

    # id: 0a9b254077729866b0ae7ab70c353807c4f802e9f0db8df7d5f27ed7cc7055bd
    # author: a4237e420cdb0b3231d171fe879bcae37a2db7abf2f12a337b975337618c3ac2
    # kind: 1
    self.assertIsNotNone(BECH32_RE.match('nevent1qqsq4xe9gpmh9xrxkzh84dcvx5uq038cqt5lpkud7l2lylkhe3c9t0gzyzjzxljzpndskv3369clapumet3h5tdh40e0z23n0wt4xdmp3savyqcyqqqqqqgzg95fu'))

  def test_uri_re(self):
    self.assertIsNone(URI_RE.search(ID))
    self.assertIsNone(URI_RE.search(NPUB))
    self.assertIsNone(URI_RE.search(PUBKEY_URI))

    matches = list(URI_RE.finditer(URI))
    self.assertEqual(1, len(matches))
    self.assertEqual(URI, matches[0].group(0))

    matches = list(URI_RE.finditer(f'a {URI} b x{URI} ({URI_NEVENT}) \n c {URI_NPROFILE} d'))
    self.assertEqual([URI, URI_NEVENT, URI_NPROFILE], [m.group(0) for m in matches])
